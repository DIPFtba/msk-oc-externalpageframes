<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#scoring-alle-ewk">Scoring (alle EWK)</a></li>
<li><a href="#scoring-bedingungen">Scoring: Bedingungen</a><ul>
<li><a href="#vergleichsoperatoren">Vergleichsoperatoren</a></li>
<li><a href="#logische-operatoren">Logische Operatoren</a></li>
<li><a href="#math-operatoren">Math. Operatoren</a></li>
<li><a href="#funktionen">Funktionen</a></li></ul></li>
<li><a href="#markierbarer-balken-filledbar">Markierbarer Balken (filledBar)</a></li>
<li><a href="#freihand-malenmarkieren-freepaint">Freihand Malen/Markieren (freePaint)</a></li>
<li><a href="#eingabefeld-mit-buttons-inputinserts">Eingabefeld mit Buttons (inputInserts)</a></li>
<li><a href="#zahlenstrahl-mit-bögen-numberlinewitharcs">Zahlenstrahl mit Bögen (numberLineWithArcs)</a></li>
</ul>
<h1 id="scoring-alle-ewk">Scoring (alle EWK)</h1>
<ul>
<li><p>In den meisten Komponenten unter Reiter "Daten", Abschnitt "Scoring-Werte"</p></li>
<li><p>Weist <code>V_Score_&lt;pref&gt;</code> einen Wert zu, wenn entsprechende Bedingung WAHR ist</p></li>
<li><p>Werte und Bedingungen werden in Reihenfolge der Definition abgearbeitet, bei erster zutreffender Bedingung wird abgebrochen, darauf folgende Werte/Bedingungen werden <strong>nicht</strong> ausgewertet. Reihenfolge der Definition muss daran angepasst werden und muss nicht z.B. nach aufsteigendem Wert sortiert sein</p></li>
</ul>
<h2 id="scoring-bedingungen">Scoring: Bedingungen</h2>
<ul>
<li><p>Klammern "( )" können beliebig zur Gruppierung verwendet werden</p></li>
<li><p>Variablen müssen durch <code>${ XYZ }</code> gekennzeichnet, wobei "XYZ" der komplette oder der letzte Teil eines Variablennamens sein muss, so dass dieser Variablenname eindeutig ist, z.B. <code>${Lab_1}</code>, <code>${ArcCnt}</code> oder <code>${Val}</code>. Nur <code>${_1}</code> zu verwenden, wenn es z.B. <code>V_Variable_1a_Lab_1</code> und <code>V_Variable_1a_Val_1</code> in einer Komponente gibt, reicht nicht aus</p></li>
<li><p>Soll der "Variablen-Prefix" der Komponente mit in einer Variablen-Referfenz enthalten sein (weil der komplette Variablenname angegeben wird), dann nicht den Prefix selbst einsetzen, sondern statt dessen <code>&lt;pref&gt;</code> verwenden. Wenn also z.B. der Variablen-Prefix der Komponente <code>1a</code> lautet und die Variable <code>V_Input_1a_Lab_1</code> referenziert werden soll, dann muss <code>${V_Input_&lt;pref&gt;_Lab_1}</code> in der Bedingung verwendet werden</p></li>
<li><p>Um die Eingabe der Variablen zu vereinfachen, wird die komplette Variablen-Referenz in die Zwischenablage kopiert, wenn in der Variablen-Liste rechts auf eine Variable geklickt wird</p></li>
<li><p>Zur Evaluation der Bedingung wird die Bibliothek <code>expr-eval</code> verwendet, s. <a href="https://github.com/silentmatt/expr-eval?tab=readme-ov-file#expression-syntax">Doku</a></p></li>
</ul>
<h4 id="vergleichsoperatoren">Vergleichsoperatoren</h4>
<table>
<thead>
<tr>
<th style="text-align:center;">Operator</th>
<th style="text-align:left;">Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">==</td>
<td style="text-align:left;">Gleichheitsoperator</td>
</tr>
<tr>
<td style="text-align:center;">!=</td>
<td style="text-align:left;">Ungleichheitsoperator</td>
</tr>
<tr>
<td style="text-align:center;">&gt;</td>
<td style="text-align:left;">Größer-als-Operator</td>
</tr>
<tr>
<td style="text-align:center;">&lt;</td>
<td style="text-align:left;">Kleiner-als-Operator</td>
</tr>
<tr>
<td style="text-align:center;">&gt;=</td>
<td style="text-align:left;">Größer-oder-gleich-Operator</td>
</tr>
<tr>
<td style="text-align:center;">&lt;=</td>
<td style="text-align:left;">Kleiner-oder-gleich-Operator</td>
</tr>
<tr>
<td style="text-align:center;">in</td>
<td style="text-align:left;">IN-Operator, ergibt TRUE, wenn linker Operand in rechtem Array-Operand enthalten ist</td>
</tr>
</tbody>
</table>
<h4 id="logische-operatoren">Logische Operatoren</h4>
<table>
<thead>
<tr>
<th style="text-align:center;">Operator</th>
<th style="text-align:left;">Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">and</td>
<td style="text-align:left;">Der logische UND-Operator gibt <code>true</code> zurück, wenn beide Operanden <code>true</code> sind.</td>
</tr>
<tr>
<td style="text-align:center;">or</td>
<td style="text-align:left;">Der logische ODER-Operator gibt <code>true</code> zurück, wenn mindestens einer der Operanden <code>true</code> ist.</td>
</tr>
<tr>
<td style="text-align:center;">not</td>
<td style="text-align:left;">Der logische NICHT-Operator invertiert den Wert eines Operanden.</td>
</tr>
</tbody>
</table>
<h4 id="math-operatoren">Math. Operatoren</h4>
<table>
<thead>
<tr>
<th style="text-align:center;">Operand</th>
<th style="text-align:left;">Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">+</td>
<td style="text-align:left;">Der Addition-Operator addiert zwei Werte.</td>
</tr>
<tr>
<td style="text-align:center;">-</td>
<td style="text-align:left;">Der Subtraktions-Operator subtrahiert einen Wert von einem anderen.</td>
</tr>
<tr>
<td style="text-align:center;">*</td>
<td style="text-align:left;">Der Multiplikations-Operator multipliziert zwei Werte.</td>
</tr>
<tr>
<td style="text-align:center;">/</td>
<td style="text-align:left;">Der Divisions-Operator teilt einen Wert durch einen anderen.</td>
</tr>
<tr>
<td style="text-align:center;">%</td>
<td style="text-align:left;">Der Modulo-Operator gibt den Rest der Division zweier Werte zurück.</td>
</tr>
</tbody>
</table>
<h4 id="funktionen">Funktionen</h4>
<p>folgende Funktionen sind in allen EWK definiert:</p>
<table>
<thead>
<tr>
<th style="text-align:left;">Funktion</th>
<th style="text-align:left;">Bsp</th>
<th style="text-align:left;">Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"><code>length( s )</code></td>
<td style="text-align:left;"><code>length( ${Val} ) &gt; 5</code></td>
<td style="text-align:left;">Ergibt Länge des Strings s</td>
</tr>
<tr>
<td style="text-align:left;"><code>strEqual( s1, s2 )</code></td>
<td style="text-align:left;"><code>strEqual( ${Input_1}, "text" )</code></td>
<td style="text-align:left;">Überprüft Gleichheit von s1 und s2 ohne Groß-/Kleinschreibung</td>
</tr>
<tr>
<td style="text-align:left;"><code>isBetween( v, w1, w2 )</code></td>
<td style="text-align:left;"><code>isBetween( ${Value_1}, 50, 80 )</code></td>
<td style="text-align:left;">Überprüft, ob w1 &lt;= v &lt;= w2</td>
</tr>
<tr>
<td style="text-align:left;"><code>match( s, r )</code></td>
<td style="text-align:left;"><code>match( ${Input}, /^Ganzer Text$/i )</code></td>
<td style="text-align:left;">Testet String s mit RegExp r</td>
</tr>
<tr>
<td style="text-align:left;"><code>isNumUnit( s, num, unitRE, unitOpt, orEmpty )</code></td>
<td style="text-align:left;"><code>isNumUnit( ${Input_1}, 80, "[mM][bB]", true, false )</code></td>
<td style="text-align:left;">Überprüft, ob String s die numerischen Wert num und die Einheit unitRE (als RegExp) als "num Unit" oder "Unit num" enthält (unitOpt=true bedeutet, die Einheit ist optional; orEmpty=true bedeutet, der ganze String darf leer sein)</td>
</tr>
</tbody>
</table>
<h1 id="markierbarer-balken-filledbar">Markierbarer Balken (filledBar)</h1>
<ul>
<li><p>"<strong>Markierbar nur Vielfache von</strong>" spezifiziert, welche Werte markiert werden können. Zur Auswahl stehen "kleine Ticks" (dann können nur kleine Ticks markiert werden, je nachdem, wie diese definiert sind), "1er", "10er" oder "(frei)" (dann ist Markierung frei wählbar, auch alle Zwischenwerte)</p></li>
<li><p>Um statt der voreingestellten 100 markierbaren Felder z.B. nur 10 zu haben, gibt es folgende Möglichkeiten:</p>
<ol>
<li>Die Schrittweite der kleinen Ticks auf 10 stellen und die großen Ticks ausschalten</li>
<li>Den Maximalwert auf 10 setzen, Schrittweite der kleinen Ticks auf 1 lassen</li>
<li>Die kleinen Ticks ausschalten und "Markierung nur Vielfache von" auf 10er setzen</li></ol>
<p>Das sind alles gleichwertige Lösungen, nur der Wertebereich des gespeicherten "markierten Wert" ist unterschiedlich</p></li>
</ul>
<h1 id="freihand-malenmarkieren-freepaint">Freihand Malen/Markieren (freePaint)</h1>
<ul>
<li><p>Im Reiter <code>PaintArea</code> wird der Bereich spezifiziert, in dem Pinsel/Marker verwendet werden können. Der sollte die Icons nicht beinhalten.</p></li>
<li><p>Die PaintArea kann einen Rahmen haben (Rahmendicke&gt;0) und/oder eine Füllung ("Füllung" einschalten). Rahmen/Füllung werden immer im Hintergrund gemalt und sind durch Marker/Pinsel übermalbar. Marker/Pinsel sind standardmäßig aber nur innerhalb des Rahmens verwendbar, sodass der Rahmen der PaintArea normalerweise nicht übermalbar ist.</p></li>
<li><p>Im Reiter <code>Rechteck / Linien</code> sind zusätzliche Rechtecke und/oder Linien definierbar. Die Rahmen der Rechtecke und die Linien sind <strong>IMMER im Vordergund</strong>, also nicht mit Pinsel/Marker übermalbar. <code>Füllg. Ebene</code> gibt bei Rechtecken an, ob diese keine Füllung haben (=0), oder Füllung im Hintergund (=1, mit Pinsel/Marker übermalbar) oder Füllung im Vordergrund (=2, nicht übermalbar) haben</p></li>
<li><p>Bei Rechtecken kann durch <code>begr. Pinsel</code> und/oder <code>begr. Marker</code> eingeschaltet werden, dass Pinsel/Marker nur in diesem (und allen anderen mit dieser aktivierten Option) Rechtecken malen und <strong>NICHT</strong> (wie Standard) innerhalb der PaintArea</p></li>
</ul>
<h1 id="eingabefeld-mit-buttons-inputinserts">Eingabefeld mit Buttons (inputInserts)</h1>
<ul>
<li><p>Im Reiter <code>Daten</code> können <code>Scoring-Muster</code> angegeben werden, die dann unter <code>Scoring-Werte</code> beliebig kombiniert werden können</p></li>
<li><p>Ein <code>Scoring-Muster</code> besteht aus einem <code>VarName</code>, einem <code>Term</code> und Optionen. Die Variable mit dem angegebenen Namen wird auf <code>1</code> gesetzt, wenn die Eingabe dem <code>Term</code> entspricht, ansonsten auf 0</p></li>
<li><p>Ein <code>Term</code> besteht aus einer Operation mit zwei oder mehreren Operanden, und optional einem obligatorischem/optionalem Ergebnis. Wird ein obligatorisches Ergebnis mit angegeben <code>= &lt;Wert&gt;</code>, muss das Ergebnis auch in der Eingabe enthalten sein, wird ein optionales Ergebnis angegeben <code>[ = &lt;Wert&gt;]</code>, dann kann dieses (aber kein anderes) Ergebnis in der EIngabe enthalten sein, um die Variable auf <code>1</code> zu setzen. Beispiele: <code>1 + 3</code>, <code>4 * 5 * 2</code>, <code>20 / 4 [ = 5]</code>, <code>10 - 6 = 4</code></p></li>
<li><p>Wird einem Operand/Ergebnis ein <code>!</code> vorangestellt, bedeutet dies, das hier JEDER AUßER DEM SPEZIFIZIERTEN Operand als richtig gewertet wird. So können z.B. Muster wie "3 mal [irgendwas außer 4]" geprüft werden: <code>3 * !4</code></p></li>
<li><p>Wird statt eines Zahlen-Operanden/Ergebnisses ein <code>.</code> verwendet, bedeutet dies JEDE ZAHL. So können z.B. Muster wie "Irgendeine Multiplikation": <code>. * .</code> oder "Multiplikation mit Ergebnis": <code>. * . = .</code> oder "3 mal [irgendwas]": <code>3 * .</code> geprüft werden</p></li>
<li><p>Die Option <code>OP-Perm</code> gibt an, ob die Operanden beliebig vertauscht sein dürfen</p></li>
<li><p>Die Option <code>Mehr erlaubt</code> gibt an, ob vor/hinter dem Term auch noch weitere Eingabe erlaubt sind, die die Bewertung nicht beeinflussen</p></li>
</ul>
<h1 id="zahlenstrahl-mit-bögen-numberlinewitharcs">Zahlenstrahl mit Bögen (numberLineWithArcs)</h1>
<ul>
<li><p>Alle Labels und Bögen werden in aufsteigender Reihenfolge sortiert, diese Reihenfolge bestimmt die Zuordnung der Variablen <code>XYZ_1</code>, <code>XYZ_2</code> etc. So geben <code>V_Input_&lt;pref&gt;_ArcFrom_1</code> und <code>V_Input_&lt;pref&gt;_ArcTo_1</code> den am weitesten links befindlichen Bogen wieder, nicht den in der JSON Config als ersten definierten Bogen. Falls ein User ein Bogen weiter links definiert, wird der erste Bogen automatisch zu <code>V_Input_&lt;pref&gt;_ArcFrom_2</code> und <code>V_Input_&lt;pref&gt;_ArcTo_2</code>. Das muss auch beim Scoring beachtet werden.</p></li>
<li><p>Auch die <code>Von</code> (<code>_ArcFom_X</code>) und <code>Bis</code> (<code>_ArcTo_X</code>) Werte werden sortiert, sodass immer <code>Von &lt; Bis</code> gilt. Die Definition im JSON Configfile ist nicht entscheidend, ebenso ist egal, ob der Bogen von links nach rechts oder von rechts nach links erstellt wird</p></li>
<li><p>Damit die Zuordnung der Variablen klarer ist, sollten also die Labels und Bögen bereits sortiert (Reihenfolge in der Tabelle) im JSON Configfile definiert werden</p></li>
<li><p>Die Option <code>Keine neuen Bögen zulassen</code> macht nur Sinn, wenn keine Bögen vordefiniert werden und im Reiter <code>Achsenlabels</code> die Option <code>Labels ohne Bögen nicht löschen</code> aktiviert wird. Dann können Labels bzw. Beschriftungen am Zahlenstrahl erzeugt, bewegt und beschriftet werden (ohne Bögen). Die Option <code>Maximalzahl</code> im Reiter <code>Achsenlabels</code> begrenzt dann die mögliche Anzahl</p></li>
</ul>